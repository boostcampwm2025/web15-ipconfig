import type { Camera } from '@/common/types/camera';
import { useRef, type Dispatch, type SetStateAction, useCallback } from 'react';
import { createContext } from '@/common/contexts/createContext';
import type { FrameInfo } from '@/common/types/canvas';
import { useCanvasStore } from '@/common/store/canvas';

interface CanvasContext {
  camera: Camera;
  setCamera: Dispatch<SetStateAction<Camera>>;
  frameRef: React.RefObject<HTMLDivElement | null>;
  getFrameInfo: () => FrameInfo;
}

const [CanvasContextProvider, useCanvasContext] = createContext<CanvasContext>({
  contextName: 'CanvasContext',
  hookName: 'useCanvasContext',
  providerName: 'CanvasContextProvider',
});

export function CanvasProvider({ children }: { children: React.ReactNode }) {
  const { camera, setCamera } = useCanvasStore();
  const frameRef = useRef<HTMLDivElement>(null);

  const getFrameInfo = useCallback(() => {
    if (!frameRef.current) return { left: 0, top: 0, width: 0, height: 0 };
    const rect = frameRef.current.getBoundingClientRect();
    return {
      left: rect.left,
      top: rect.top,
      width: rect.width,
      height: rect.height,
    } as const;
  }, [frameRef]);

  return (
    <CanvasContextProvider
      value={{ camera, setCamera, frameRef, getFrameInfo }}
    >
      {children}
    </CanvasContextProvider>
  );
}

// eslint-disable-next-line react-refresh/only-export-components
export function useCanvas() {
  return useCanvasContext();
}
